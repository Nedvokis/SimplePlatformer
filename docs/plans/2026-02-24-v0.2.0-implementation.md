# v0.2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add death counter with HUD, victory screen, logging with file output, comprehensive testing, justfile, and level creation documentation.

**Architecture:** Extend existing Bevy ECS plugin architecture. New `DeathCounter` resource tracks deaths across levels. New `Victory` game state and `VictoryPlugin` for end-game screen. Custom `tracing` Layer with ring buffer for log file. TDD approach — tests first, then implementation.

**Tech Stack:** Rust, Bevy 0.18, avian2d 0.5, tracing (via Bevy), just (command runner)

---

### Task 1: Add `Victory` state to `GameState`

**Files:**
- Modify: `src/states.rs:4-12`

**Step 1: Add Victory variant**

In `src/states.rs`, add `Victory` to the `GameState` enum:

```rust
#[derive(States, Debug, Clone, PartialEq, Eq, Hash, Default)]
pub enum GameState {
    #[default]
    Menu,
    LevelSelect,
    LevelTransition,
    Playing,
    Paused,
    Settings,
    Victory,
}
```

**Step 2: Verify compilation**

Run: `cargo check`
Expected: success (Victory is added but not yet used)

**Step 3: Commit**

```bash
git add src/states.rs
git commit -m "feat: add Victory state to GameState enum"
```

---

### Task 2: Add `DeathCounter` resource

**Files:**
- Modify: `src/player.rs`

**Step 1: Define the resource**

Add to `src/player.rs` after `SpawnPoint`:

```rust
#[derive(Resource, Default)]
pub struct DeathCounter {
    pub current_level: usize,
    pub total: usize,
}
```

**Step 2: Register resource in PlayerPlugin**

In `PlayerPlugin::build`, add after `init_resource::<SpawnPoint>()`:

```rust
.init_resource::<DeathCounter>()
```

**Step 3: Reset `current_level` on level enter**

Add a new system registered on `OnEnter(GameState::Playing)`:

```rust
fn reset_level_deaths(mut counter: ResMut<DeathCounter>) {
    counter.current_level = 0;
}
```

Register it in `PlayerPlugin::build`:

```rust
.add_systems(OnEnter(GameState::Playing), (spawn_player, reset_level_deaths))
```

(Replace the existing `.add_systems(OnEnter(GameState::Playing), spawn_player)` line.)

**Step 4: Increment counter in `player_death`**

Change `player_death` signature to include `DeathCounter`:

```rust
fn player_death(
    mut query: Query<(&mut Transform, &mut LinearVelocity), With<Player>>,
    spawn_point: Res<SpawnPoint>,
    mut counter: ResMut<DeathCounter>,
) {
    for (mut transform, mut velocity) in &mut query {
        if transform.translation.y < -500.0 {
            transform.translation = spawn_point.0.extend(0.0);
            *velocity = LinearVelocity::ZERO;
            counter.current_level += 1;
        }
    }
}
```

**Step 5: Verify compilation**

Run: `cargo check`
Expected: success

**Step 6: Commit**

```bash
git add src/player.rs
git commit -m "feat: add DeathCounter resource with reset and fall-death increment"
```

---

### Task 3: Increment `DeathCounter` on spike death

**Files:**
- Modify: `src/level.rs:223-240`

**Step 1: Add DeathCounter to check_spikes**

Import `DeathCounter` at top of `src/level.rs`:

```rust
use crate::player::{Player, SpawnPoint, DeathCounter};
```

Change `check_spikes` signature:

```rust
fn check_spikes(
    spikes_query: Query<&CollidingEntities, With<Spikes>>,
    player_query: Query<(), With<Player>>,
    mut player_transform_query: Query<(&mut Transform, &mut LinearVelocity), With<Player>>,
    spawn_point: Res<SpawnPoint>,
    mut counter: ResMut<DeathCounter>,
) {
    for colliding in &spikes_query {
        for &entity in colliding.iter() {
            if player_query.get(entity).is_ok() {
                for (mut transform, mut velocity) in &mut player_transform_query {
                    transform.translation = spawn_point.0.extend(0.0);
                    *velocity = LinearVelocity::ZERO;
                }
                counter.current_level += 1;
                return;
            }
        }
    }
}
```

**Step 2: Verify compilation**

Run: `cargo check`
Expected: success

**Step 3: Commit**

```bash
git add src/level.rs
git commit -m "feat: increment DeathCounter on spike death"
```

---

### Task 4: Add HUD showing death count

**Files:**
- Modify: `src/level.rs`

**Step 1: Add HUD component and spawn system**

Add component at top of `src/level.rs`:

```rust
#[derive(Component)]
pub struct DeathHud;
```

Add system to spawn HUD (called on `OnEnter(GameState::Playing)`):

```rust
fn spawn_hud(mut commands: Commands) {
    commands.spawn((
        DeathHud,
        Text::new("Deaths: 0"),
        TextFont {
            font_size: 24.0,
            ..default()
        },
        TextColor(Color::WHITE),
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(20.0),
            top: Val::Px(20.0),
            ..default()
        },
        DespawnOnExit::<GameState>(GameState::Playing),
    ));
}
```

Add update system:

```rust
fn update_hud(
    counter: Res<DeathCounter>,
    mut query: Query<&mut Text, With<DeathHud>>,
) {
    if counter.is_changed() {
        for mut text in &mut query {
            **text = format!("Deaths: {}", counter.current_level);
        }
    }
}
```

**Step 2: Register systems in LevelPlugin**

Add `spawn_hud` to `OnEnter(GameState::Playing)`:

```rust
.add_systems(OnEnter(GameState::Playing), (load_level, spawn_hud))
```

Add `update_hud` to Update:

```rust
.add_systems(
    Update,
    (check_exit, check_spikes, update_hud).run_if(in_state(GameState::Playing)),
)
```

**Step 3: Add import**

Add to imports in `src/level.rs`:

```rust
use crate::player::{Player, SpawnPoint, DeathCounter};
```

(Already added in Task 3, ensure `DeathCounter` is there.)

**Step 4: Verify compilation and test manually**

Run: `cargo run`
Expected: "Deaths: 0" in top-left corner, increments on death

**Step 5: Commit**

```bash
git add src/level.rs
git commit -m "feat: add HUD showing death count per level"
```

---

### Task 5: Add `VictoryPlugin` with victory screen

**Files:**
- Create: `src/victory.rs`
- Modify: `src/main.rs`

**Step 1: Create `src/victory.rs`**

```rust
use bevy::prelude::*;

use crate::player::DeathCounter;
use crate::states::GameState;

#[derive(Component)]
struct VictoryAction;

pub struct VictoryPlugin;

impl Plugin for VictoryPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Victory), spawn_victory_screen)
            .add_systems(
                Update,
                victory_action.run_if(in_state(GameState::Victory)),
            );
    }
}

fn death_comment(total: usize) -> &'static str {
    match total {
        0 => " - flawless!",
        69 => " - nice",
        42 => " - the answer!",
        100 => " - centurion!",
        _ if total > 200 => " - respect for perseverance!",
        _ => "",
    }
}

fn spawn_victory_screen(
    mut commands: Commands,
    counter: Res<DeathCounter>,
) {
    let total = counter.total;
    let comment = death_comment(total);

    commands
        .spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            DespawnOnExit::<GameState>(GameState::Victory),
        ))
        .with_children(|parent| {
            // Title
            parent.spawn((
                Text::new("CONGRATULATIONS!"),
                TextFont {
                    font_size: 60.0,
                    ..default()
                },
                TextColor(Color::srgb(0.9, 0.8, 0.2)),
                Node {
                    margin: UiRect::bottom(Val::Px(30.0)),
                    ..default()
                },
            ));

            // Death count
            parent.spawn((
                Text::new(format!("You died: {}{}", total, comment)),
                TextFont {
                    font_size: 32.0,
                    ..default()
                },
                TextColor(Color::WHITE),
                Node {
                    margin: UiRect::bottom(Val::Px(40.0)),
                    ..default()
                },
            ));

            // Main Menu button
            parent
                .spawn((
                    Button,
                    VictoryAction,
                    Node {
                        width: Val::Px(300.0),
                        height: Val::Px(50.0),
                        justify_content: JustifyContent::Center,
                        align_items: AlignItems::Center,
                        ..default()
                    },
                    BackgroundColor(Color::srgb(0.3, 0.3, 0.7)),
                ))
                .with_children(|btn| {
                    btn.spawn((
                        Text::new("Main Menu"),
                        TextFont {
                            font_size: 24.0,
                            ..default()
                        },
                        TextColor(Color::WHITE),
                    ));
                });
        });
}

fn victory_action(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut next_state: ResMut<NextState<GameState>>,
    mut commands: Commands,
    buttons: Query<&Interaction, (With<VictoryAction>, Changed<Interaction>)>,
) {
    let enter = keyboard.just_pressed(KeyCode::Enter);
    let clicked = buttons.iter().any(|i| *i == Interaction::Pressed);

    if enter || clicked {
        commands.remove_resource::<DeathCounter>();
        next_state.set(GameState::Menu);
    }
}
```

**Step 2: Register in `src/main.rs`**

Add `mod victory;` after `mod states;` and add plugin:

```rust
mod victory;
```

```rust
use victory::VictoryPlugin;
```

Add `.add_plugins(VictoryPlugin)` after SettingsPlugin.

**Step 3: Verify compilation**

Run: `cargo check`
Expected: success

**Step 4: Commit**

```bash
git add src/victory.rs src/main.rs
git commit -m "feat: add VictoryPlugin with congratulations screen"
```

---

### Task 6: Wire `check_exit` to transition to Victory on last level

**Files:**
- Modify: `src/level.rs:193-217`

**Step 1: Update `check_exit` to accumulate deaths and route to Victory**

```rust
fn check_exit(
    exit_query: Query<&CollidingEntities, With<Exit>>,
    player_query: Query<(), With<Player>>,
    mut current_level: ResMut<CurrentLevel>,
    mut progress: ResMut<PlayerProgress>,
    mut next_state: ResMut<NextState<GameState>>,
    mut counter: ResMut<DeathCounter>,
) {
    for colliding in &exit_query {
        for &entity in colliding.iter() {
            if player_query.get(entity).is_ok() {
                // Accumulate deaths
                counter.total += counter.current_level;

                current_level.0 += 1;
                if current_level.0 > progress.max_unlocked_level {
                    progress.max_unlocked_level = current_level.0;
                    crate::progress::save_progress(&progress);
                }
                if current_level.0 < LEVELS.len() {
                    next_state.set(GameState::LevelTransition);
                } else {
                    next_state.set(GameState::Victory);
                }
                return;
            }
        }
    }
}
```

Note: the only changes vs current code are:
- Added `mut counter: ResMut<DeathCounter>` parameter
- Added `counter.total += counter.current_level;` line
- Changed `GameState::LevelSelect` to `GameState::Victory` in the else branch

**Step 2: Clean up DeathCounter on return to Menu from Pause**

In `src/pause.rs`, the "Main Menu" action (index 2) should also remove DeathCounter. Update `pause_action`:

```rust
fn pause_action(
    keyboard: Res<ButtonInput<KeyCode>>,
    selected: Res<SelectedPauseItem>,
    mut next_state: ResMut<NextState<GameState>>,
    mut settings_origin: ResMut<SettingsOrigin>,
    mut commands: Commands,
    buttons: Query<(&PauseAction, &Interaction)>,
) {
    let enter = keyboard.just_pressed(KeyCode::Enter);
    let clicked = buttons.iter().any(|(_, i)| *i == Interaction::Pressed);

    if !enter && !clicked {
        return;
    }

    match selected.0 {
        0 => {
            next_state.set(GameState::Playing);
        }
        1 => {
            *settings_origin = SettingsOrigin::Paused;
            next_state.set(GameState::Settings);
        }
        2 => {
            commands.remove_resource::<DeathCounter>();
            next_state.set(GameState::Menu);
        }
        _ => {}
    }
}
```

Add import at top of `src/pause.rs`:

```rust
use crate::player::DeathCounter;
```

**Step 3: Verify with `cargo run`**

Run: `cargo run`
Expected: play through all 5 levels → Victory screen appears with total deaths

**Step 4: Commit**

```bash
git add src/level.rs src/pause.rs
git commit -m "feat: wire check_exit to Victory state, accumulate deaths"
```

---

### Task 7: Add logging with ring buffer and file output

**Files:**
- Create: `src/logging.rs`
- Modify: `src/main.rs`
- Modify: `Cargo.toml`

**Step 1: Add `tracing-subscriber` dependency**

In `Cargo.toml`, add:

```toml
tracing-subscriber = { version = "0.3", features = ["fmt", "registry"] }
tracing = "0.1"
```

Note: Bevy already uses tracing internally, these are for the custom Layer.

**Step 2: Create `src/logging.rs`**

```rust
use bevy::prelude::*;
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use tracing_subscriber::Layer;

const MAX_LOG_ENTRIES: usize = 50;
const FLUSH_INTERVAL_SECS: f32 = 30.0;

/// Shared ring buffer for log entries.
#[derive(Clone)]
pub struct LogRingBuffer(pub Arc<Mutex<VecDeque<String>>>);

impl Default for LogRingBuffer {
    fn default() -> Self {
        Self(Arc::new(Mutex::new(VecDeque::with_capacity(MAX_LOG_ENTRIES))))
    }
}

/// Resource wrapper for the ring buffer (Bevy ECS access).
#[derive(Resource, Clone)]
pub struct LogBuffer(pub LogRingBuffer);

/// Timer resource for periodic flush.
#[derive(Resource)]
struct LogFlushTimer(Timer);

/// Custom tracing Layer that writes to the ring buffer.
pub struct RingBufferLayer {
    buffer: LogRingBuffer,
}

impl RingBufferLayer {
    pub fn new(buffer: LogRingBuffer) -> Self {
        Self { buffer }
    }
}

impl<S> Layer<S> for RingBufferLayer
where
    S: tracing::Subscriber,
{
    fn on_event(
        &self,
        event: &tracing::Event<'_>,
        _ctx: tracing_subscriber::layer::Context<'_, S>,
    ) {
        let metadata = event.metadata();
        let level = metadata.level();

        // Only capture INFO and above (skip DEBUG/TRACE from other crates)
        if *level > tracing::Level::DEBUG {
            return;
        }

        // Format the message
        let mut visitor = MessageVisitor(String::new());
        event.record(&mut visitor);

        let now = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
        let target = metadata.target();
        let entry = format!("[{}] {:<5} {}: {}", now, level, target, visitor.0);

        if let Ok(mut buf) = self.buffer.0.lock() {
            if buf.len() >= MAX_LOG_ENTRIES {
                buf.pop_front();
            }
            buf.push_back(entry);
        }
    }
}

struct MessageVisitor(String);

impl tracing::field::Visit for MessageVisitor {
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn std::fmt::Debug) {
        if field.name() == "message" {
            self.0 = format!("{:?}", value);
        }
    }

    fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
        if field.name() == "message" {
            self.0 = value.to_string();
        }
    }
}

fn log_path() -> std::path::PathBuf {
    let base = dirs::data_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
    let dir = base.join("simple_platformer");
    std::fs::create_dir_all(&dir).ok();
    dir.join("game.log")
}

fn flush_to_file(buffer: &LogRingBuffer) {
    if let Ok(buf) = buffer.0.lock() {
        let content: String = buf.iter().map(|s| s.as_str()).collect::<Vec<_>>().join("\n");
        let path = log_path();
        std::fs::write(path, content).ok();
    }
}

fn periodic_flush(
    time: Res<Time>,
    mut timer: ResMut<LogFlushTimer>,
    log_buffer: Res<LogBuffer>,
) {
    if timer.0.tick(time.delta()).just_finished() {
        flush_to_file(&log_buffer.0);
    }
}

fn flush_on_exit(
    mut exit_events: EventReader<AppExit>,
    log_buffer: Res<LogBuffer>,
) {
    for _ in exit_events.read() {
        flush_to_file(&log_buffer.0);
    }
}

pub struct LoggingPlugin;

impl Plugin for LoggingPlugin {
    fn build(&self, app: &mut App) {
        let ring_buffer = LogRingBuffer::default();
        app.insert_resource(LogBuffer(ring_buffer.clone()))
            .insert_resource(LogFlushTimer(Timer::from_seconds(
                FLUSH_INTERVAL_SECS,
                TimerMode::Repeating,
            )))
            .add_systems(Update, (periodic_flush, flush_on_exit));
    }
}

/// Call this from main() BEFORE App::new() to set up the tracing subscriber.
/// Returns the ring buffer so it can be inserted into the Bevy app.
pub fn setup_tracing() -> LogRingBuffer {
    use tracing_subscriber::layer::SubscriberExt;
    use tracing_subscriber::util::SubscriberInitExt;

    let ring_buffer = LogRingBuffer::default();

    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer().with_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "simple_platformer=info".parse().unwrap()),
        ))
        .with(RingBufferLayer::new(ring_buffer.clone()))
        .init();

    ring_buffer
}
```

Wait — Bevy's `DefaultPlugins` already includes `LogPlugin` which sets up tracing. We need to either disable `LogPlugin` and set up our own, or add our layer differently.

**Revised approach:** Disable Bevy's `LogPlugin` from `DefaultPlugins`, set up tracing ourselves with both the console layer and our ring buffer layer. Update `src/main.rs` accordingly.

**Step 2 (revised): Add `chrono` dependency too**

```toml
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter", "registry"] }
tracing = "0.1"
chrono = "0.4"
```

**Step 3: Create `src/logging.rs`**

(Use the code above but with the corrected `setup_tracing` that returns a `LogRingBuffer`.)

**Step 4: Update `src/main.rs`**

```rust
mod logging;
```

```rust
use logging::{LoggingPlugin, LogBuffer, LogRingBuffer};
```

Disable Bevy's LogPlugin and pass the ring buffer:

```rust
fn main() {
    let ring_buffer = logging::setup_tracing();

    App::new()
        .add_plugins(DefaultPlugins
            .set(WindowPlugin {
                primary_window: Some(Window {
                    title: "SimplePlatformer".to_string(),
                    resolution: (1280u32, 720u32).into(),
                    ..default()
                }),
                ..default()
            })
            .disable::<bevy::log::LogPlugin>()
        )
        .insert_resource(LogBuffer(ring_buffer))
        .add_plugins(LoggingPlugin)
        // ... rest of plugins
```

**Step 5: Add `info!` / `debug!` calls to key systems**

In `src/level.rs` — `load_level`:
```rust
info!("Loaded level {} '{}' ({} tiles)", index + 1, level.name, level.tiles.len());
```

In `src/level.rs` — `check_exit`:
```rust
info!("Level {} completed (deaths: {})", current_level.0, counter.current_level);
```

In `src/level.rs` — `check_spikes`:
```rust
debug!("Death by spikes (level deaths: {})", counter.current_level);
```

In `src/player.rs` — `player_death`:
```rust
debug!("Death by falling (level deaths: {})", counter.current_level);
```

In `src/progress.rs` — `save_progress`:
```rust
use bevy::log::{info, error};

pub fn save_progress(progress: &PlayerProgress) {
    let path = save_path();
    match serde_json::to_string_pretty(progress) {
        Ok(json) => {
            if let Err(e) = std::fs::write(&path, json) {
                error!("Failed to save progress: {}", e);
            } else {
                info!("Progress saved (max_level: {})", progress.max_unlocked_level);
            }
        }
        Err(e) => error!("Failed to serialize progress: {}", e),
    }
}
```

In `src/progress.rs` — `load_progress`:
```rust
fn load_progress() -> PlayerProgress {
    let path = save_path();
    match std::fs::read_to_string(&path) {
        Ok(s) => match serde_json::from_str(&s) {
            Ok(p) => {
                info!("Progress loaded from {:?}", path);
                p
            }
            Err(e) => {
                error!("Failed to parse progress: {}", e);
                PlayerProgress::default()
            }
        },
        Err(_) => {
            info!("No save file found, starting fresh");
            PlayerProgress::default()
        }
    }
}
```

**Step 6: Verify**

Run: `cargo run`
Expected: console shows info logs, file created at `~/.local/share/simple_platformer/game.log`

**Step 7: Commit**

```bash
git add Cargo.toml src/logging.rs src/main.rs src/level.rs src/player.rs src/progress.rs
git commit -m "feat: add logging with ring buffer and file output"
```

---

### Task 8: Unit tests for `merge_platform_runs`

**Files:**
- Modify: `src/level.rs`

**Step 1: Write tests at bottom of `src/level.rs`**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    fn tile(x: i32, y: i32, kind: TileKind) -> TileEntry {
        TileEntry { x, y, kind }
    }

    #[test]
    fn merge_adjacent_platforms() {
        let tiles = vec![
            tile(0, 0, TileKind::Platform),
            tile(1, 0, TileKind::Platform),
            tile(2, 0, TileKind::Platform),
        ];
        let runs = merge_platform_runs(&tiles);
        assert_eq!(runs.len(), 1);
        assert_eq!(runs[0], (0, 0, 3));
    }

    #[test]
    fn merge_with_gap() {
        let tiles = vec![
            tile(0, 0, TileKind::Platform),
            tile(1, 0, TileKind::Platform),
            tile(5, 0, TileKind::Platform),
            tile(6, 0, TileKind::Platform),
        ];
        let runs = merge_platform_runs(&tiles);
        assert_eq!(runs.len(), 2);
        assert!(runs.contains(&(0, 0, 2)));
        assert!(runs.contains(&(5, 0, 2)));
    }

    #[test]
    fn spikes_not_merged() {
        let tiles = vec![
            tile(0, 0, TileKind::Platform),
            tile(1, 0, TileKind::Spikes),
            tile(2, 0, TileKind::Platform),
        ];
        let runs = merge_platform_runs(&tiles);
        assert_eq!(runs.len(), 2);
        assert!(runs.contains(&(0, 0, 1)));
        assert!(runs.contains(&(2, 0, 1)));
    }

    #[test]
    fn different_rows() {
        let tiles = vec![
            tile(0, 0, TileKind::Platform),
            tile(1, 0, TileKind::Platform),
            tile(0, 1, TileKind::Platform),
            tile(1, 1, TileKind::Platform),
        ];
        let runs = merge_platform_runs(&tiles);
        assert_eq!(runs.len(), 2);
        assert!(runs.contains(&(0, 0, 2)));
        assert!(runs.contains(&(0, 1, 2)));
    }

    #[test]
    fn empty_tiles() {
        let runs = merge_platform_runs(&[]);
        assert!(runs.is_empty());
    }

    #[test]
    fn single_platform() {
        let tiles = vec![tile(5, 3, TileKind::Platform)];
        let runs = merge_platform_runs(&tiles);
        assert_eq!(runs.len(), 1);
        assert_eq!(runs[0], (5, 3, 1));
    }
}
```

**Step 2: Run tests**

Run: `cargo test -- level::tests`
Expected: all 6 tests pass

**Step 3: Commit**

```bash
git add src/level.rs
git commit -m "test: add unit tests for merge_platform_runs"
```

---

### Task 9: Unit tests for level RON parsing

**Files:**
- Modify: `src/level.rs` (add to existing `tests` module)

**Step 1: Add parsing tests**

```rust
#[test]
fn parse_level_from_ron() {
    let ron_str = r#"
        LevelData(
            name: "Test",
            spawn: (1.0, 2.0),
            exit: (10.0, 5.0),
            tiles: [
                TileEntry(x: 0, y: 0, kind: Platform),
                TileEntry(x: 1, y: 0, kind: Spikes),
            ],
        )
    "#;
    let level: LevelData = ron::from_str(ron_str).unwrap();
    assert_eq!(level.name, "Test");
    assert_eq!(level.spawn, (1.0, 2.0));
    assert_eq!(level.exit, (10.0, 5.0));
    assert_eq!(level.tiles.len(), 2);
    assert!(matches!(level.tiles[0].kind, TileKind::Platform));
    assert!(matches!(level.tiles[1].kind, TileKind::Spikes));
}

#[test]
fn parse_all_level_files() {
    for path in LEVELS {
        let contents = std::fs::read_to_string(path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {}", path, e));
        let level: LevelData = ron::from_str(&contents)
            .unwrap_or_else(|e| panic!("Failed to parse {}: {}", path, e));
        assert!(!level.name.is_empty(), "Level {} has empty name", path);
        assert!(!level.tiles.is_empty(), "Level {} has no tiles", path);
    }
}
```

**Step 2: Run tests**

Run: `cargo test -- level::tests`
Expected: all 8 tests pass

**Step 3: Commit**

```bash
git add src/level.rs
git commit -m "test: add unit tests for level RON parsing"
```

---

### Task 10: Unit tests for progress save/load

**Files:**
- Modify: `src/progress.rs`

**Step 1: Make save_path configurable for testing**

Refactor `save_progress` and `load_progress` to accept a path parameter internally. Add test-only helpers:

```rust
fn save_progress_to(progress: &PlayerProgress, path: &std::path::Path) {
    match serde_json::to_string_pretty(progress) {
        Ok(json) => {
            if let Err(e) = std::fs::write(path, json) {
                bevy::log::error!("Failed to save progress: {}", e);
            } else {
                bevy::log::info!("Progress saved (max_level: {})", progress.max_unlocked_level);
            }
        }
        Err(e) => bevy::log::error!("Failed to serialize progress: {}", e),
    }
}

fn load_progress_from(path: &std::path::Path) -> PlayerProgress {
    match std::fs::read_to_string(path) {
        Ok(s) => match serde_json::from_str(&s) {
            Ok(p) => p,
            Err(_) => PlayerProgress::default(),
        },
        Err(_) => PlayerProgress::default(),
    }
}

pub fn save_progress(progress: &PlayerProgress) {
    save_progress_to(progress, &save_path());
}

fn load_progress() -> PlayerProgress {
    load_progress_from(&save_path())
}
```

**Step 2: Add tests**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    #[test]
    fn save_load_roundtrip() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("test_save.json");

        let progress = PlayerProgress { max_unlocked_level: 3 };
        save_progress_to(&progress, &path);

        let loaded = load_progress_from(&path);
        assert_eq!(loaded.max_unlocked_level, 3);
    }

    #[test]
    fn load_missing_file_returns_default() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("nonexistent.json");

        let loaded = load_progress_from(&path);
        assert_eq!(loaded.max_unlocked_level, 0);
    }

    #[test]
    fn load_corrupted_json_returns_default() {
        let dir = tempfile::tempdir().unwrap();
        let path = dir.path().join("bad.json");
        let mut f = std::fs::File::create(&path).unwrap();
        f.write_all(b"not json at all {{{").unwrap();

        let loaded = load_progress_from(&path);
        assert_eq!(loaded.max_unlocked_level, 0);
    }
}
```

**Step 3: Add `tempfile` dev dependency**

In `Cargo.toml`:

```toml
[dev-dependencies]
tempfile = "3"
```

**Step 4: Run tests**

Run: `cargo test -- progress::tests`
Expected: all 3 tests pass

**Step 5: Commit**

```bash
git add Cargo.toml src/progress.rs
git commit -m "test: add unit tests for progress save/load"
```

---

### Task 11: Integration tests for player death and DeathCounter

**Files:**
- Modify: `src/player.rs`

**Step 1: Add integration tests**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use bevy::app::App;
    use avian2d::prelude::*;

    fn test_app() -> App {
        let mut app = App::new();
        app.add_plugins(MinimalPlugins);
        app.init_resource::<SpawnPoint>();
        app.init_resource::<DeathCounter>();
        app
    }

    #[test]
    fn death_counter_increments_on_fall() {
        let mut app = test_app();
        app.insert_resource(SpawnPoint(Vec2::new(64.0, 64.0)));

        // Spawn player below death threshold
        app.world_mut().spawn((
            Player,
            Grounded(false),
            Transform::from_xyz(0.0, -600.0, 0.0),
            LinearVelocity(Vec2::new(100.0, -50.0)),
        ));

        app.add_systems(Update, player_death);
        app.update();

        let counter = app.world().resource::<DeathCounter>();
        assert_eq!(counter.current_level, 1);
    }

    #[test]
    fn no_death_above_threshold() {
        let mut app = test_app();

        app.world_mut().spawn((
            Player,
            Grounded(false),
            Transform::from_xyz(0.0, 100.0, 0.0),
            LinearVelocity::ZERO,
        ));

        app.add_systems(Update, player_death);
        app.update();

        let counter = app.world().resource::<DeathCounter>();
        assert_eq!(counter.current_level, 0);
    }

    #[test]
    fn respawn_resets_position_and_velocity() {
        let mut app = test_app();
        let spawn = Vec2::new(64.0, 64.0);
        app.insert_resource(SpawnPoint(spawn));

        let entity = app.world_mut().spawn((
            Player,
            Grounded(false),
            Transform::from_xyz(0.0, -600.0, 0.0),
            LinearVelocity(Vec2::new(100.0, -200.0)),
        )).id();

        app.add_systems(Update, player_death);
        app.update();

        let transform = app.world().entity(entity).get::<Transform>().unwrap();
        assert_eq!(transform.translation.x, spawn.x);
        assert_eq!(transform.translation.y, spawn.y);

        let velocity = app.world().entity(entity).get::<LinearVelocity>().unwrap();
        assert_eq!(velocity.0, Vec2::ZERO);
    }

    #[test]
    fn reset_level_deaths_clears_current() {
        let mut app = test_app();
        app.world_mut().resource_mut::<DeathCounter>().current_level = 5;

        app.add_systems(Update, reset_level_deaths);
        app.update();

        let counter = app.world().resource::<DeathCounter>();
        assert_eq!(counter.current_level, 0);
        // total should remain unchanged
        assert_eq!(counter.total, 0);
    }
}
```

**Step 2: Run tests**

Run: `cargo test -- player::tests`
Expected: all 4 tests pass

**Step 3: Commit**

```bash
git add src/player.rs
git commit -m "test: add integration tests for player death and DeathCounter"
```

---

### Task 12: Integration test for Victory state transition

**Files:**
- Modify: `src/victory.rs`

**Step 1: Add test for death_comment**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn death_comment_special_values() {
        assert_eq!(death_comment(0), " - flawless!");
        assert_eq!(death_comment(69), " - nice");
        assert_eq!(death_comment(42), " - the answer!");
        assert!(death_comment(5).is_empty());
        assert!(!death_comment(250).is_empty()); // >200 gets a comment
    }
}
```

**Step 2: Run tests**

Run: `cargo test -- victory::tests`
Expected: pass

**Step 3: Commit**

```bash
git add src/victory.rs
git commit -m "test: add tests for victory death_comment"
```

---

### Task 13: Create Justfile

**Files:**
- Create: `justfile`

**Step 1: Create justfile in project root**

```just
# SimplePlatformer build commands

# Extract version from Cargo.toml
version := `grep '^version' Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/'`

# Run the game in debug mode
run:
    cargo run

# Build release binary
build:
    cargo build --release

# Fast compilation check
check:
    cargo check

# Run linter
lint:
    cargo clippy

# Run all tests
test:
    cargo test

# Clean build artifacts
clean:
    cargo clean

# Build and package for Linux and Windows
package: _package-linux _package-windows
    @echo "Packages created in dist/"
    @ls -la dist/*.zip

# Package Linux build
_package-linux:
    cargo build --release --target x86_64-unknown-linux-gnu
    @mkdir -p dist/SimplePlatformer-v{{version}}-linux-x86_64
    cp target/x86_64-unknown-linux-gnu/release/simple_platformer dist/SimplePlatformer-v{{version}}-linux-x86_64/
    cp -r assets dist/SimplePlatformer-v{{version}}-linux-x86_64/
    cd dist && zip -r SimplePlatformer-v{{version}}-linux-x86_64.zip SimplePlatformer-v{{version}}-linux-x86_64/
    rm -rf dist/SimplePlatformer-v{{version}}-linux-x86_64/

# Package Windows build (requires mingw-w64)
_package-windows:
    cargo build --release --target x86_64-pc-windows-gnu
    @mkdir -p dist/SimplePlatformer-v{{version}}-windows-x86_64
    cp target/x86_64-pc-windows-gnu/release/simple_platformer.exe dist/SimplePlatformer-v{{version}}-windows-x86_64/
    cp -r assets dist/SimplePlatformer-v{{version}}-windows-x86_64/
    cd dist && zip -r SimplePlatformer-v{{version}}-windows-x86_64.zip SimplePlatformer-v{{version}}-windows-x86_64/
    rm -rf dist/SimplePlatformer-v{{version}}-windows-x86_64/
```

**Step 2: Add `dist/` to `.gitignore`**

Append to `.gitignore`:

```
dist/
```

**Step 3: Verify basic commands**

Run: `just test`
Expected: all tests pass

Run: `just lint`
Expected: no warnings

**Step 4: Commit**

```bash
git add justfile .gitignore
git commit -m "build: add justfile with run/build/test/lint/package commands"
```

---

### Task 14: Write level creation guide

**Files:**
- Create: `docs/LEVEL_CREATION_GUIDE.md`

**Step 1: Write the guide**

Write `docs/LEVEL_CREATION_GUIDE.md` in Russian, containing:

1. **Введение** — уровни хранятся в `assets/levels/level_NN.ron`, формат RON
2. **Структура LevelData** — описание полей `name`, `spawn`, `exit`, `tiles`
3. **Типы тайлов** — `Platform` (серые блоки, твёрдые), `Spikes` (красные, убивают)
4. **Система координат** — тайловые: 1 тайл = 32px, x вправо, y вверх, (0,0) = нижний левый угол
5. **Пример минимального уровня** — полный RON-файл с комментариями
6. **Советы по дизайну**:
   - Максимальный преодолимый gap: ~3 тайла
   - Максимальная высота прыжка: ~3 тайла
   - Спаун игрока должен быть над платформой
   - Выход должен быть рядом с платформой
7. **Как добавить уровень** — создать файл `level_NN.ron`, добавить путь в `LEVELS` массив в `src/level.rs`

**Step 2: Commit**

```bash
git add docs/LEVEL_CREATION_GUIDE.md
git commit -m "docs: add level creation guide"
```

---

### Task 15: Update version to 0.2.0 and final cleanup

**Files:**
- Modify: `Cargo.toml:3` — change `version = "0.1.0"` to `version = "0.2.0"`
- Modify: `CLAUDE.md` — update if needed

**Step 1: Update version**

In `Cargo.toml`:

```toml
version = "0.2.0"
```

**Step 2: Run full test suite**

Run: `just test`
Expected: all tests pass

Run: `just lint`
Expected: no warnings

**Step 3: Manual smoke test**

Run: `just run`
Expected: play through a level, see HUD, die, see counter increment, complete all levels, see Victory screen

**Step 4: Commit**

```bash
git add Cargo.toml CLAUDE.md
git commit -m "chore: bump version to 0.2.0"
```
